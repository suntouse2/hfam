"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoRetry = autoRetry;
const platform_node_js_1 = require("./platform.node.js");
const debug = (0, platform_node_js_1.debug)("grammy:auto-retry");
const ONE_HOUR = 3600; // seconds
const INITIAL_LAST_DELAY = 3; // seconds
function pause(seconds, signal) {
    return new Promise((resolve, reject) => {
        const handle = setTimeout(() => {
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", abort);
            resolve();
        }, 1000 * seconds);
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", abort);
        function abort() {
            clearTimeout(handle);
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", abort);
            reject(new Error("Request aborted while waiting between retries"));
        }
    });
}
/**
 * Creates an [API transformer
 * function](https://grammy.dev/advanced/transformers.html) that will check
 * failed API requests for a `retry_after` value, and attempt to perform them
 * again after waiting the specified number of seconds.
 *
 * You can set an option to only retry requests a number of times, or only retry
 * those that to not demand your bot to wait too long.
 *
 * @param options Configuration options
 * @returns The created API transformer function
 */
function autoRetry(options) {
    var _a, _b, _c, _d;
    const maxDelay = (_a = options === null || options === void 0 ? void 0 : options.maxDelaySeconds) !== null && _a !== void 0 ? _a : Infinity;
    const maxRetries = (_b = options === null || options === void 0 ? void 0 : options.maxRetryAttempts) !== null && _b !== void 0 ? _b : Infinity;
    const rethrowInternalServerErrors = (_c = options === null || options === void 0 ? void 0 : options.rethrowInternalServerErrors) !== null && _c !== void 0 ? _c : false;
    const rethrowHttpErrors = (_d = options === null || options === void 0 ? void 0 : options.rethrowHttpErrors) !== null && _d !== void 0 ? _d : false;
    return async (prev, method, payload, signal) => {
        var _a;
        let remainingAttempts = maxRetries;
        let nextDelay = INITIAL_LAST_DELAY;
        async function backoff() {
            await pause(nextDelay, signal);
            // exponential backoff, capped at one hour
            nextDelay = Math.min(ONE_HOUR, nextDelay + nextDelay);
        }
        async function call() {
            let res = undefined;
            while (res === undefined) {
                try {
                    res = await prev(method, payload, signal);
                }
                catch (e) {
                    if ((signal === undefined || !signal.aborted) &&
                        !rethrowHttpErrors && e instanceof platform_node_js_1.HttpError) {
                        debug(`HttpError thrown, will retry '${method}' after ${nextDelay} seconds (${e.message})`);
                        await backoff();
                        continue;
                    }
                    else {
                        throw e;
                    }
                }
            }
            return res;
        }
        let result = undefined;
        do {
            let retry = false;
            result = await call();
            if (typeof ((_a = result.parameters) === null || _a === void 0 ? void 0 : _a.retry_after) === "number" &&
                result.parameters.retry_after <= maxDelay) {
                debug(`Hit rate limit, will retry '${method}' after ${result.parameters.retry_after} seconds`);
                await pause(result.parameters.retry_after, signal);
                nextDelay = INITIAL_LAST_DELAY;
                retry = true;
            }
            else if (result.error_code >= 500 &&
                !rethrowInternalServerErrors) {
                debug(`Hit internal server error, will retry '${method}' after ${nextDelay} seconds`);
                await backoff();
                retry = true;
            }
            if (!retry)
                return result;
        } while (!result.ok && remainingAttempts-- > 0);
        return result;
    };
}
