import type { MessageEntity } from "./deps.node.js";
/**
 * Represents an entity tag used for formatting text via fmt.
 */
export type EntityTag = Omit<MessageEntity, "offset" | "length">;
/**
 * Objects that implement this interface implement a `.toString()`
 * method that returns a `string` value representing the object.
 */
export interface Stringable {
    /**
     * Returns the string representation of this object
     */
    toString(): string;
}
/**
 * Represents text object with optional formatting entities.
 *
 * This interface is used to store plain text along with its associated
 * formatting information (such as bold, italic, links, etc.) as message entities.
 *
 * @example
 * ```typescript
 * const formattedText: TextWithEntities = {
 *   text: "Hello world!",
 *   entities: [
 *     { type: "bold", offset: 0, length: 5 },
 *     { type: "italic", offset: 6, length: 5 }
 *   ]
 * };
 * ```
 */
export interface TextWithEntities {
    /**
     * Plain text value for this `FormattedString`
     */
    text: string;
    /**
     * Format entities for this `FormattedString`
     */
    entities?: MessageEntity[];
}
/**
 * Represents caption object with optional formatting entities.
 *
 * This interface is used to store plain caption along with its associated
 * formatting information (such as bold, italic, links, etc.) as message entities.
 *
 * @example
 * ```typescript
 * const formattedCaption: CaptionWithEntities = {
 *   caption: "Hello world!",
 *   caption_entities: [
 *     { type: "bold", offset: 0, length: 5 },
 *     { type: "italic", offset: 6, length: 5 }
 *   ]
 * };
 * ```
 */
export interface CaptionWithEntities {
    /**
     * Plain caption value for this `FormattedString`
     */
    caption: string;
    /**
     * Format caption_entities for this `FormattedString`
     */
    caption_entities?: MessageEntity[];
}
/**
 * Represents the formatted string after parsing. This class provides a unified
 * interface for working with formatted text that can be used as both message text
 * and caption content in Telegram Bot API calls.
 */
export declare class FormattedString implements TextWithEntities, CaptionWithEntities, Stringable {
    rawText: string;
    /**
     * The entities backing this FormattedString.
     */
    rawEntities: MessageEntity[];
    /**
     * Creates a new `FormattedString` instance.
     *
     * @param rawText The plain text content
     * @param rawEntities The formatting entities that apply to the text
     *
     * @example
     * ```typescript
     * const formatted = new FormattedString("Hello world!", [
     *   { type: "bold", offset: 0, length: 5 },
     *   { type: "italic", offset: 6, length: 5 }
     * ]);
     * ```
     */
    constructor(rawText: string, rawEntities?: MessageEntity[]);
    /**
     * Gets the caption text. This is an alias for the raw text content.
     * Used when this FormattedString is used as caption content.
     */
    get caption(): string;
    /**
     * Gets the plain text content. This is an alias for the raw text content.
     * Used when this FormattedString is used as message text.
     */
    get text(): string;
    /**
     * Gets the caption entities. This is an alias for the raw entities.
     * Used when this FormattedString is used as caption content.
     */
    get caption_entities(): MessageEntity[];
    /**
     * Gets the message entities. This is an alias for the raw entities.
     * Used when this FormattedString is used as message text.
     */
    get entities(): MessageEntity[];
    /**
     * Returns the string representation of this `FormattedString` object
     */
    toString(): string;
    /**
     * Creates a bold formatted string
     * @param text The text content to format as bold
     * @returns A new FormattedString with bold formatting applied
     */
    static b(text: Stringable): FormattedString;
    /**
     * Creates a bold formatted string
     * @param text The text content to format as bold
     * @returns A new FormattedString with bold formatting applied
     */
    static bold(text: Stringable): FormattedString;
    /**
     * Creates an italic formatted string
     * @param text The text content to format as italic
     * @returns A new FormattedString with italic formatting applied
     */
    static i(text: Stringable): FormattedString;
    /**
     * Creates an italic formatted string
     * @param text The text content to format as italic
     * @returns A new FormattedString with italic formatting applied
     */
    static italic(text: Stringable): FormattedString;
    /**
     * Creates a strikethrough formatted string
     * @param text The text content to format with strikethrough
     * @returns A new FormattedString with strikethrough formatting applied
     */
    static s(text: Stringable): FormattedString;
    /**
     * Creates a strikethrough formatted string
     * @param text The text content to format with strikethrough
     * @returns A new FormattedString with strikethrough formatting applied
     */
    static strikethrough(text: Stringable): FormattedString;
    /**
     * Creates an underline formatted string
     * @param text The text content to format with underline
     * @returns A new FormattedString with underline formatting applied
     */
    static u(text: Stringable): FormattedString;
    /**
     * Creates an underline formatted string
     * @param text The text content to format with underline
     * @returns A new FormattedString with underline formatting applied
     */
    static underline(text: Stringable): FormattedString;
    /**
     * Creates a link formatted string
     * @param text The text content to display as a link
     * @param url The URL to link to
     * @returns A new FormattedString with link formatting applied
     */
    static a(text: Stringable, url: string): FormattedString;
    /**
     * Creates a link formatted string
     * @param text The text content to display as a link
     * @param url The URL to link to
     * @returns A new FormattedString with link formatting applied
     */
    static link(text: Stringable, url: string): FormattedString;
    /**
     * Creates a code formatted string
     * @param text The text content to format as inline code
     * @returns A new FormattedString with code formatting applied
     */
    static code(text: Stringable): FormattedString;
    /**
     * Creates a pre formatted string (code block)
     * @param text The text content to format as a code block
     * @param language The programming language for syntax highlighting
     * @returns A new FormattedString with pre formatting applied
     */
    static pre(text: Stringable, language: string): FormattedString;
    /**
     * Creates a spoiler formatted string
     * @param text The text content to format as a spoiler
     * @returns A new FormattedString with spoiler formatting applied
     */
    static spoiler(text: Stringable): FormattedString;
    /**
     * Creates a blockquote formatted string
     * @param text The text content to format as a blockquote
     * @returns A new FormattedString with blockquote formatting applied
     */
    static blockquote(text: Stringable): FormattedString;
    /**
     * Creates an expandable blockquote formatted string
     * @param text The text content to format as an expandable blockquote
     * @returns A new FormattedString with expandable blockquote formatting applied
     */
    static expandableBlockquote(text: Stringable): FormattedString;
    /**
     * Creates a user mention formatted string
     * @param text The text content to display for the mention
     * @param userId The Telegram user ID to mention
     * @returns A new FormattedString with user mention formatting applied
     */
    static mentionUser(text: Stringable, userId: number): FormattedString;
    /**
     * Creates a custom emoji formatted string
     * @param placeholder The placeholder emoji text to display
     * @param emoji The custom emoji identifier
     * @returns A new FormattedString with custom emoji formatting applied
     */
    static customEmoji(placeholder: Stringable, emoji: string): FormattedString;
    /**
     * Creates a message link formatted string
     * @param text The text content to display for the link
     * @param chatId The chat ID containing the message
     * @param messageId The message ID to link to
     * @returns A new FormattedString with message link formatting applied
     */
    static linkMessage(text: Stringable, chatId: number, messageId: number): FormattedString;
    /**
     * Joins an array of formatted strings or plain text into a single FormattedString
     * @param items Array of text items to join (can be TextWithEntities, CaptionWithEntities, or string)
     * @param separator Optional separator to insert between items (defaults to empty string)
     * @returns A new FormattedString combining all items
     */
    static join(items: (Stringable | TextWithEntities | CaptionWithEntities | string)[], separator?: Stringable | TextWithEntities | CaptionWithEntities | string): FormattedString;
    /**
     * Internal method that implements the shared splitting logic for both split and splitByText methods
     * @param text The FormattedString to split
     * @param separator The FormattedString separator to split by
     * @param isSplitByTextOnly If true, ignore entities for separator. Defaults to false.
     * @returns An array of FormattedString segments
     */
    protected static _split(text: FormattedString, separator: FormattedString, isSplitByTextOnly?: boolean): FormattedString[];
    /**
     * Splits a FormattedString into an array of FormattedStrings using a separator
     * @param text The FormattedString to split
     * @param separator The FormattedString separator to split by (must match both rawText and rawEntities exactly)
     * @returns An array of FormattedString segments
     */
    static split(text: FormattedString, separator: FormattedString): FormattedString[];
    /**
     * Splits a FormattedString into an array of FormattedStrings using a separator,
     * ignoring inequalities in rawEntities. Only uses rawText to determine if this is a valid position to split.
     * @param text The FormattedString to split
     * @param separator The FormattedString separator to split by (only rawText is used for matching)
     * @returns An array of FormattedString segments
     */
    static splitByText(text: FormattedString, separator: FormattedString): FormattedString[];
    /**
     * Combines this FormattedString with a bold formatted string
     * @param text The text content to format as bold and append
     * @returns A new FormattedString combining this instance with bold formatting
     */
    b(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a bold formatted string
     * @param text The text content to format as bold and append
     * @returns A new FormattedString combining this instance with bold formatting
     */
    bold(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with an italic formatted string
     * @param text The text content to format as italic and append
     * @returns A new FormattedString combining this instance with italic formatting
     */
    i(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with an italic formatted string
     * @param text The text content to format as italic and append
     * @returns A new FormattedString combining this instance with italic formatting
     */
    italic(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a strikethrough formatted string
     * @param text The text content to format with strikethrough and append
     * @returns A new FormattedString combining this instance with strikethrough formatting
     */
    s(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a strikethrough formatted string
     * @param text The text content to format with strikethrough and append
     * @returns A new FormattedString combining this instance with strikethrough formatting
     */
    strikethrough(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with an underline formatted string
     * @param text The text content to format with underline and append
     * @returns A new FormattedString combining this instance with underline formatting
     */
    u(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with an underline formatted string
     * @param text The text content to format with underline and append
     * @returns A new FormattedString combining this instance with underline formatting
     */
    underline(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a link formatted string
     * @param text The text content to display as a link and append
     * @param url The URL to link to
     * @returns A new FormattedString combining this instance with link formatting
     */
    a(text: Stringable, url: string): FormattedString;
    /**
     * Combines this FormattedString with a link formatted string
     * @param text The text content to display as a link and append
     * @param url The URL to link to
     * @returns A new FormattedString combining this instance with link formatting
     */
    link(text: Stringable, url: string): FormattedString;
    /**
     * Combines this FormattedString with a code formatted string
     * @param text The text content to format as inline code and append
     * @returns A new FormattedString combining this instance with code formatting
     */
    code(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a pre formatted string (code block)
     * @param text The text content to format as a code block and append
     * @param language The programming language for syntax highlighting
     * @returns A new FormattedString combining this instance with pre formatting
     */
    pre(text: Stringable, language: string): FormattedString;
    /**
     * Combines this FormattedString with a spoiler formatted string
     * @param text The text content to format as a spoiler and append
     * @returns A new FormattedString combining this instance with spoiler formatting
     */
    spoiler(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a blockquote formatted string
     * @param text The text content to format as a blockquote and append
     * @returns A new FormattedString combining this instance with blockquote formatting
     */
    blockquote(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with an expandable blockquote formatted string
     * @param text The text content to format as an expandable blockquote and append
     * @returns A new FormattedString combining this instance with expandable blockquote formatting
     */
    expandableBlockquote(text: Stringable): FormattedString;
    /**
     * Combines this FormattedString with a user mention formatted string
     * @param text The text content to display for the mention and append
     * @param userId The Telegram user ID to mention
     * @returns A new FormattedString combining this instance with user mention formatting
     */
    mentionUser(text: Stringable, userId: number): FormattedString;
    /**
     * Combines this FormattedString with a custom emoji formatted string
     * @param placeholder The placeholder emoji text to display and append
     * @param emoji The custom emoji identifier
     * @returns A new FormattedString combining this instance with custom emoji formatting
     */
    customEmoji(placeholder: Stringable, emoji: string): FormattedString;
    /**
     * Combines this FormattedString with a message link formatted string
     * @param text The text content to display for the link and append
     * @param chatId The chat ID containing the message
     * @param messageId The message ID to link to
     * @returns A new FormattedString combining this instance with message link formatting
     */
    linkMessage(text: Stringable, chatId: number, messageId: number): FormattedString;
    /**
     * Combines this FormattedString with plain text
     * @param text The plain text content to append
     * @returns A new FormattedString combining this instance with the plain text
     */
    plain(text: string): FormattedString;
    /**
     * Splits this FormattedString into an array of FormattedStrings using a separator
     * @param separator The FormattedString separator to split by (must match both rawText and rawEntities exactly)
     * @returns An array of FormattedString segments
     */
    split(separator: FormattedString): FormattedString[];
    /**
     * Splits this FormattedString into an array of FormattedStrings using a separator,
     * ignoring inequalities in rawEntities. Only uses rawText to determine if this is a valid position to split.
     * @param separator The FormattedString separator to split by (only rawText is used for matching)
     * @returns An array of FormattedString segments
     */
    splitByText(separator: FormattedString): FormattedString[];
    /**
     * Returns a copy of a portion of this FormattedString
     * @param start The start index (inclusive), defaults to 0
     * @param end The end index (exclusive), defaults to text length
     * @returns A new FormattedString containing the sliced text and properly adjusted entities
     */
    slice(start?: number, end?: number): FormattedString;
    /**
     * Protected method that finds pattern matches within this FormattedString.
     * @param pattern The FormattedString pattern to search for
     * @param options Configuration options for the search
     * @returns Array of match offsets
     */
    protected _findMatches(pattern: FormattedString, options?: {
        findAll?: boolean;
        allowOverlapping?: boolean;
        matchByTextOnly?: boolean;
    }): number[];
    /**
     * Finds the first occurrence of a FormattedString pattern within this FormattedString
     * that matches both the raw text and raw entities exactly.
     * @param pattern The FormattedString pattern to search for
     * @returns The offset where the pattern is found, or -1 if not found
     */
    find(pattern: FormattedString): number;
    /**
     * Finds all occurrences of a FormattedString pattern within this FormattedString
     * that match both the raw text and raw entities exactly.
     * @param pattern The FormattedString pattern to search for
     * @param allowOverlapping If true, allows overlapping matches; defaults to false (non-overlapping)
     * @returns Array of offsets where the pattern is found, or empty array if not found
     */
    findAll(pattern: FormattedString, allowOverlapping?: boolean): number[];
    /**
     * Protected method to replace matches at given offsets with a replacement.
     * @param pattern The FormattedString pattern being replaced (needed for length calculation)
     * @param replacement The FormattedString to replace matches with
     * @param matchOffsets Array of offsets where matches were found
     * @returns A new FormattedString with matches replaced
     */
    protected replaceMatches(pattern: FormattedString, replacement: FormattedString, matchOffsets: number[]): FormattedString;
    /**
     * Returns a new FormattedString with the first occurrence of pattern replaced by replacement.
     * Both the raw text and raw entities must match exactly for replacement to occur.
     * @param pattern The FormattedString pattern to search for and replace
     * @param replacement The FormattedString to replace the pattern with
     * @returns A new FormattedString with the first match replaced, or a copy if no match found
     */
    replace(pattern: FormattedString, replacement: FormattedString): FormattedString;
    /**
     * Returns a new FormattedString with all occurrences of pattern replaced by replacement.
     * Both the raw text and raw entities must match exactly for replacement to occur.
     * @param pattern The FormattedString pattern to search for and replace
     * @param replacement The FormattedString to replace the pattern with
     * @returns A new FormattedString with all matches replaced, or a copy if no matches found
     */
    replaceAll(pattern: FormattedString, replacement: FormattedString): FormattedString;
    /**
     * Concatenates this FormattedString with one or more other FormattedStrings
     * @param formattedStrings One or more FormattedString instances to concatenate
     * @returns A new FormattedString combining this instance with all provided FormattedStrings
     */
    concat(...formattedStrings: FormattedString[]): FormattedString;
    /**
     * Checks whether this FormattedString starts with the specified pattern.
     * Both the raw text and raw entities must match exactly.
     * @param pattern The FormattedString pattern to check for at the beginning
     * @returns true if this FormattedString starts with the pattern, false otherwise
     */
    startsWith(pattern: FormattedString): boolean;
    /**
     * Checks whether this FormattedString ends with the specified pattern.
     * Both the raw text and raw entities must match exactly.
     * @param pattern The FormattedString pattern to check for at the end
     * @returns true if this FormattedString ends with the pattern, false otherwise
     */
    endsWith(pattern: FormattedString): boolean;
    /**
     * Static method to check whether a FormattedString starts with the specified pattern.
     * Both the raw text and raw entities must match exactly.
     * @param source The FormattedString to check
     * @param pattern The FormattedString pattern to check for at the beginning
     * @returns true if the source starts with the pattern, false otherwise
     */
    static startsWith(source: FormattedString, pattern: FormattedString): boolean;
    /**
     * Static method to check whether a FormattedString ends with the specified pattern.
     * Both the raw text and raw entities must match exactly.
     * @param source The FormattedString to check
     * @param pattern The FormattedString pattern to check for at the end
     * @returns true if the source ends with the pattern, false otherwise
     */
    static endsWith(source: FormattedString, pattern: FormattedString): boolean;
}
/**
 * Alias for `bold` entity tag. Incompatible with `code` and `pre`.
 */
export declare function b(): EntityTag;
/**
 * `bold` entity tag. Incompatible with `code` and `pre`.
 */
export declare function bold(): EntityTag;
/**
 * Alias for `italic` entity tag. Incompatible with `code` and `pre`.
 */
export declare function i(): EntityTag;
/**
 * `italic` entity tag. Incompatible with `code` and `pre`.
 */
export declare function italic(): EntityTag;
/**
 * Alias for `strikethrough` entity tag. Incompatible with `code` and `pre`.
 */
export declare function s(): EntityTag;
/**
 * `strikethrough` entity tag. Incompatible with `code` and `pre`.
 */
export declare function strikethrough(): EntityTag;
/**
 * Alias for `underline` entity tag. Incompatible with `code` and `pre`.
 */
export declare function u(): EntityTag;
/**
 * `underline` entity tag. Incompatible with `code` and `pre`.
 */
export declare function underline(): EntityTag;
/**
 * Alias for `link` entity tag. Incompatible with `code` and `pre`.
 * @param url The URL to link to.
 */
export declare function a(url: string): EntityTag;
/**
 * `link` entity tag. Incompatible with `code` and `pre`.
 * @param url The URL to link to.
 */
export declare function link(url: string): EntityTag;
/**
 * `code` entity tag. Cannot be combined with any other formats.
 */
export declare function code(): EntityTag;
/**
 * `pre` entity tag. Cannot be combined with any other formats.
 * @param language The language of the code block.
 */
export declare function pre(language: string): EntityTag;
/**
 * `spoiler` entity tag. Incompatible with `code` and `pre`.
 */
export declare function spoiler(): EntityTag;
/**
 * `blockquote` entity tag. Cannot be nested.
 */
export declare function blockquote(): EntityTag;
/**
 * `expandable_blockquote` entity tag. Cannot be nested.
 */
export declare function expandableBlockquote(): EntityTag;
/**
 * This is the format tagged template function. It accepts a template literal
 * containing any mix of `Stringable`, `string`, `FormattedString`,
 * `TextWithEntities`, `CaptionWithEntities`, and `EntityTag` values, and constructs
 * a `FormattedString` that represents the combination of all the given values.
 * The constructed `FormattedString` also implements Stringable, TextWithEntities,
 * and CaptionWithEntities, and can be used in further `fmt` tagged templates.
 *
 * Can also be called like regular function and passed an array of `Stringable`s.
 *
 * ```ts
 * // Using return values of fmt in fmt
 * const left = fmt`${b}bolded${b}`;
 * const right = fmt`${u}underlined${u}`;
 *
 * const combined = fmt`${left} ${ctx.msg.text} ${right}`;
 * await ctx.reply(combined.text { entities: combined.entities });
 * ```
 *
 * @param rawStringParts An array of `string` parts found in the tagged template
 * @param entityTagsOrFormattedTextObjects An array of `EntityTag`s, `FormattedString`s,
 * `TextWithEntities`, `CaptionWithEntities`, `Stringable` objects, or nullary functions
 * returning `EntityTag`s found in the tagged template
 * @returns A new FormattedString instance containing the formatted text and entities
 */
export declare function fmt(rawStringParts: TemplateStringsArray, ...entityTagsOrFormattedTextObjects: (Stringable | TextWithEntities | CaptionWithEntities | EntityTag | (() => EntityTag))[]): FormattedString;
/**
 * Formats the `Stringable` as an internal Telegram link to a user. Incompatible with `code` and `pre`.
 * @param stringLike The `Stringable` to format.
 * @param userId The user ID to link to.
 */
export declare function mentionUser(stringLike: Stringable, userId: number): FormattedString;
/**
 * Inserts a custom emoji.
 * @param placeholder A placeholder emoji
 * @param emoji The custom emoji identifier
 */
export declare function customEmoji(placeholder: Stringable, emoji: string): FormattedString;
/**
 * Formats the `Stringable` as a Telegram link to a chat message. Incompatible with `code` and `pre`.
 * @param stringLike The `Stringable` to format.
 * @param chatId The chat ID to link to.
 * @param messageId The message ID to link to.
 */
export declare function linkMessage(stringLike: Stringable, chatId: number, messageId: number): FormattedString;
